<!doctype html>
<html lang="pt">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Relatório de Consumo — Shelly (Upload CSV)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;max-width:900px;margin:24px auto;padding:0 12px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:1.4rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:14px;margin:12px 0;background:#fff}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .row > *{flex:1 1 220px}
  label{display:block;font-size:.90rem;margin:.3rem 0}
  input,select,button{width:100%;padding:8px;border:1px solid #bbb;border-radius:8px}
  button{cursor:pointer}
  .muted{color:#666}
  .kpis{display:flex;gap:10px;flex-wrap:wrap}
  .kpi{flex:1 1 160px;border:1px solid #eee;border-radius:10px;padding:10px;background:#fafafa}
  .kpi .v{font-size:1.2rem}
  .error{color:#c22}
  .success{color:#0a7}
  canvas{background:#fff;border:1px solid #eee;border-radius:8px}
</style>
<body>
<header>
  <h1>Relatório de Consumo — Shelly (CSV)</h1>
  <div class="muted" id="appVersion">v2025.09.06-csv</div>
</header>

<div class="card">
  <h3>1) Carregar CSV exportado da app Shelly</h3>
  <div class="row">
    <div>
      <label>Ficheiro CSV (podes arrastar aqui)</label>
      <input type="file" id="file" accept=".csv,text/csv">
    </div>
    <div>
      <label>Separador (deteta automático)</label>
      <select id="sep">
        <option value="auto">Auto</option>
        <option value=",">Vírgula (,)</option>
        <option value=";">Ponto e vírgula (;)</option>
        <option value="\t">Tab</option>
      </select>
    </div>
    <div>
      <label>Timezone dos dados</label>
      <select id="tz">
        <option value="local">Usar hora local do dispositivo</option>
        <option value="utc">Tratar timestamps como UTC</option>
      </select>
    </div>
  </div>
  <div class="row">
    <div>
      <label>Coluna de tempo (deteta automático)</label>
      <input id="colTime" placeholder="ex.: timestamp, time, datetime">
    </div>
    <div>
      <label>Colunas de energia (Wh/kWh) — opcional, separadas por vírgulas</label>
      <input id="colEnergy" placeholder="ex.: total_act_energy, energy_wh">
    </div>
    <div>
      <label>Colunas de potência (W) — opcional, separadas por vírgulas</label>
      <input id="colPower" placeholder="ex.: power, act_power, a_power,b_power,c_power">
    </div>
  </div>
  <div class="row">
    <button id="parse">Analisar CSV</button>
    <button id="clear">Limpar</button>
  </div>
  <small class="muted">Na app Shelly: Dispositivo → Reports/Export Data → escolhe intervalo → exporta CSV. Depois carrega aqui.</small>
  <div id="msg" class="muted"></div>
</div>

<div class="card" id="summaryCard" style="display:none">
  <h3>2) Resumo</h3>
  <div class="row">
    <div>
      <label>Dia</label>
      <input type="date" id="dayPicker">
    </div>
    <div class="kpis" style="flex: 1 1 auto">
      <div class="kpi"><div class="muted">Energia</div><div class="v" id="kpiKwh">— kWh</div></div>
      <div class="kpi"><div class="muted">Pico</div><div class="v" id="kpiPico">— W</div></div>
      <div class="kpi"><div class="muted">Média</div><div class="v" id="kpiAvg">— W</div></div>
      <div class="kpi"><div class="muted">Load factor</div><div class="v" id="kpiLF">—</div></div>
    </div>
  </div>
  <small class="muted" id="noteDay"></small>
</div>

<div class="card" id="chartsCard" style="display:none">
  <h3>3) Gráficos</h3>
  <canvas id="chartDaily" height="220"></canvas><br><br>
  <canvas id="chartWeekly" height="220"></canvas>
  <small class="muted">kWh/dia (linha) + média móvel 7d (tracejado) e kWh/semana (barras).</small>
</div>

<div class="card" id="historyCard" style="display:none">
  <h3>Histórico diário</h3>
  <div id="history"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
// ---------- util ----------
const $ = s => document.querySelector(s);
const msg = (t,cls="muted") => ($("#msg").textContent=t, $("#msg").className=cls);
const asNumber = v => (v===null||v===undefined||v==="") ? null : Number(String(v).replace(",", ".").trim());
function parseDateFlexible(s, tzMode) {
  // Tenta epoch segundos, epoch ms, ISO, 'YYYY-MM-DD HH:mm:ss'
  if (s==null) return null;
  const str = String(s).trim();
  if (/^\d{13}$/.test(str)) return new Date(Number(str));
  if (/^\d{10}$/.test(str)) return new Date(Number(str)*1000);
  // Normaliza caso venha "YYYY-MM-DD HH:mm:ss"
  const isoish = str.replace(" ", "T");
  const d = new Date(isoish);
  if (!isNaN(d)) return (tzMode==="utc") ? new Date(d.getTime()+ (new Date().getTimezoneOffset()*60000)) : d;
  return null;
}
function toISOdate(d){ return d.toISOString().slice(0,10); }

// ---------- estado ----------
let series = []; // {ts:Date, powerW?:number, energyWh?:number} (soma de canais)
let perDay = {}; // { 'YYYY-MM-DD': { kwh, minW, avgW, maxW, samples, peakAt } }

// ---------- parsing ----------
function detectColumns(headers){
  const h = headers.map(x=>String(x||"").toLowerCase().trim());
  const find = (...cands) => {
    for (const c of cands){
      const i = h.indexOf(c.toLowerCase());
      if (i>=0) return i;
    }
    // fallback: procura por includes
    for (let i=0;i<h.length;i++){
      if (cands.some(c=> h[i].includes(c.toLowerCase()))) return i;
    }
    return -1;
  };
  const iTime = find("timestamp","time","datetime","date","ts");
  // Energia cumulativa por canal: total_act_energy, energy, energy_wh, total_energy
  const energyIdx = [];
  h.forEach((name,idx)=>{
    if (/(^|_)(total_)?(act_)?energy(_wh|_kwh)?$/.test(name) || /energy(?!_per)/.test(name)) energyIdx.push(idx);
  });
  // Potência instantânea por canal: power, act_power, a_power, b_power, c_power
  const powerIdx = [];
  h.forEach((name,idx)=>{
    if (/(^|_)(act_)?power$/.test(name) || /_power$/.test(name)) powerIdx.push(idx);
  });
  return {iTime, energyIdx, powerIdx};
}

function aggregatePerDay(){
  perDay = {};
  if (!series.length) return;
  // Ordena
  series.sort((a,b)=>a.ts-b.ts);
  const byDay = {};
  for (const r of series){
    const key = toISOdate(r.ts);
    (byDay[key] ||= []).push(r);
  }
  for (const [day,arr] of Object.entries(byDay)){
    // energia via cumulativo (diferença max-min) se houver energyWh
    const eVals = arr.map(r=>r.energyWh).filter(v=>v!=null);
    let kwh = null;
    if (eVals.length>=2){
      kwh = (Math.max(...eVals)-Math.min(...eVals))/1000;
    } else {
      // integrar potência: sum(P*dt)/3600000
      let sumWh = 0;
      for (let i=1;i<arr.length;i++){
        const p0 = arr[i-1].powerW ?? 0;
        const p1 = arr[i].powerW ?? 0;
        const dt = (arr[i].ts - arr[i-1].ts); // ms
        const pAvg = (p0+p1)/2;
        sumWh += pAvg * dt / 3600000;
      }
      kwh = sumWh/1000;
    }
    // potência stats
    const pVals = arr.map(r=>r.powerW).filter(v=>v!=null);
    const minW = pVals.length? Math.min(...pVals): null;
    const maxW = pVals.length? Math.max(...pVals): null;
    const avgW = pVals.length? Math.round(pVals.reduce((a,b)=>a+b,0)/pVals.length): null;
    let peakAt = null;
    if (maxW!=null){
      const i = arr.findIndex(r=>r.powerW===maxW);
      if (i>=0) peakAt = new Date(arr[i].ts).toTimeString().slice(0,5);
    }
    perDay[day] = { kwh: +(+kwh).toFixed(3), minW, avgW, maxW, peakAt, samples: arr.length };
  }
}

// ---------- UI ----------
let chartDaily=null, chartWeekly=null;
function renderAll(){
  const days = Object.keys(perDay).sort();
  if (!days.length){ msg("Nenhum registo válido encontrado no CSV.", "error"); return; }
  $("#summaryCard").style.display = $("#chartsCard").style.display = $("#historyCard").style.display = "block";
  // day picker
  $("#dayPicker").min = days[0];
  $("#dayPicker").max = days[days.length-1];
  $("#dayPicker").value = days[days.length-1];
  renderDay($("#dayPicker").value);
  renderCharts();
  renderHistory();
  msg(`OK: ${series.length} amostras, ${days.length} dias.`, "success");
}

function loadFactor(kwh,maxW){ if (!kwh || !maxW) return null; return (kwh*1000)/(maxW*24); }

function renderDay(d){
  const r = perDay[d]||{};
  $("#kpiKwh").textContent = (r.kwh!=null)? `${r.kwh.toFixed?.(3)||r.kwh} kWh` : "— kWh";
  $("#kpiPico").textContent = (r.maxW!=null)? `${r.maxW} W ${r.peakAt?`(${r.peakAt})`:""}` : "— W";
  $("#kpiAvg").textContent  = (r.avgW!=null)? `${r.avgW} W` : "— W";
  const lf = loadFactor(r.kwh, r.maxW);
  $("#kpiLF").textContent = (lf!=null)? `${(lf*100).toFixed(1)}%` : "—";
  $("#noteDay").textContent = `Amostras: ${r.samples ?? 0}`;
}

function renderCharts(){
  const days = Object.keys(perDay).sort();
  const daily = days.map(d=> perDay[d]?.kwh ?? null);
  const mm7 = days.map((_,i)=>{
    const s = daily.slice(Math.max(0,i-6), i+1).filter(x=>x!=null);
    return s.length ? +(s.reduce((a,b)=>a+b,0)/s.length).toFixed(3) : null;
  });

  if (chartDaily) chartDaily.destroy();
  chartDaily = new Chart($("#chartDaily"), {
    type:"line",
    data:{labels:days, datasets:[
      {label:"kWh/dia", data:daily, spanGaps:true},
      {label:"Média móvel 7d", data:mm7, spanGaps:true, borderDash:[6,6]}
    ]},
    options:{responsive:true,maintainAspectRatio:false,devicePixelRatio:1,scales:{y:{beginAtZero:true}}}
  });

  // semanas ISO
  const weekMap = new Map();
  for (const d of days){
    const v = perDay[d]?.kwh; if (v==null) continue;
    const dt = new Date(d+"T00:00:00");
    const day = (dt.getDay()+6)%7;
    const thu = new Date(dt); thu.setDate(dt.getDate()-day+3);
    const week1 = new Date(thu.getFullYear(),0,4);
    const w = 1 + Math.round(((thu-week1)/86400000 - 3)/7);
    const key = `${thu.getFullYear()}-W${String(w).padStart(2,"0")}`;
    weekMap.set(key, (weekMap.get(key)||0)+v);
  }
  const weeks = [...weekMap.keys()].sort();
  const wkVals = weeks.map(k=> +weekMap.get(k).toFixed(3));

  if (chartWeekly) chartWeekly.destroy();
  chartWeekly = new Chart($("#chartWeekly"), {
    type:"bar",
    data:{labels:weeks, datasets:[{label:"kWh/semana", data:wkVals}]},
    options:{responsive:true,maintainAspectRatio:false,devicePixelRatio:1,scales:{y:{beginAtZero:true}}}
  });
}

function renderHistory(){
  const el = $("#history"); el.innerHTML="";
  const days = Object.keys(perDay).sort().reverse();
  for (const d of days){
    const r = perDay[d];
    const div = document.createElement("div");
    div.className = "row";
    div.innerHTML = `
      <div><strong>${d}</strong></div>
      <div>kWh: <strong>${r.kwh!=null ? (r.kwh.toFixed?.(3)||r.kwh) : "—"}</strong></div>
      <div>W [min/méd/máx]: ${r.minW??"—"} / ${r.avgW??"—"} / ${r.maxW??"—"}</div>
      <div>${r.peakAt?`Pico: ${r.peakAt}`:""}</div>
    `;
    el.appendChild(div);
  }
}

// ---------- handlers ----------
$("#clear").onclick = () => {
  series = []; perDay = {};
  $("#summaryCard").style.display = $("#chartsCard").style.display = $("#historyCard").style.display = "none";
  msg("Limpo.", "muted");
};

$("#dayPicker").onchange = (e)=> renderDay(e.target.value);

$("#parse").onclick = async () => {
  const file = $("#file").files?.[0];
  if (!file){ msg("Escolhe um ficheiro CSV exportado da Shelly app.", "error"); return; }
  msg("A processar CSV...", "muted");

  const sepSel = $("#sep").value;
  const tzMode = $("#tz").value;
  const colTimeManual = $("#colTime").value.trim();
  const colEnergyManual = $("#colEnergy").value.trim();
  const colPowerManual = $("#colPower").value.trim();

  const config = {
    header: true,
    skipEmptyLines: true,
    delimiter: sepSel==="auto" ? "" : (sepSel==="\t" ? "\t" : sepSel),
    transformHeader: h => h.trim()
  };
  Papa.parse(file, {
    ...config,
    complete: (res) => {
      try{
        const rows = res.data;
        if (!rows?.length) { msg("CSV sem linhas úteis.", "error"); return; }
        const headers = res.meta.fields || Object.keys(rows[0]||{});
        let {iTime, energyIdx, powerIdx} = detectColumns(headers);

        // overrides manuais
        if (colTimeManual) iTime = headers.findIndex(h=>h.toLowerCase().trim()===colTimeManual.toLowerCase().trim());
        if (colEnergyManual) {
          energyIdx = colEnergyManual.split(",").map(s=>headers.findIndex(h=>h.toLowerCase().trim()===s.trim().toLowerCase())).filter(i=>i>=0);
        }
        if (colPowerManual) {
          powerIdx = colPowerManual.split(",").map(s=>headers.findIndex(h=>h.toLowerCase().trim()===s.trim().toLowerCase())).filter(i=>i>=0);
        }

        if (iTime<0) { msg("Não encontrei coluna de tempo. Define-a manualmente.", "error"); return; }
        if (!energyIdx.length && !powerIdx.length) {
          msg("Não encontrei colunas de energia (Wh/kWh) nem potência (W). Define manualmente.", "error"); return;
        }

        // montar série somando colunas multi-canal
        series = [];
        for (const row of rows){
          const t = parseDateFlexible(row[headers[iTime]], tzMode);
          if (!t) continue;
          let eSum = null, pSum = null;

          if (energyIdx.length){
            let sum = 0, ok=false;
            for (const i of energyIdx){
              const v = asNumber(row[headers[i]]);
              if (v!=null){ sum += v; ok=true; }
            }
            if (ok) eSum = sum; // assume Wh (muitos Shelly exportam Wh). Se for kWh, o utilizador pode dividir por 1000 depois; na prática é Wh.
          }
          if (powerIdx.length){
            let sum = 0, ok=false;
            for (const i of powerIdx){
              const v = asNumber(row[headers[i]]);
              if (v!=null){ sum += v; ok=true; }
            }
            if (ok) pSum = sum;
          }
          series.push({ ts:t, energyWh: eSum, powerW: pSum });
        }

        if (!series.length){ msg("Nenhuma amostra válida após parsing.", "error"); return; }

        // Heurística: se a média de energyWh < 20, pode estar em kWh → converte p/ Wh
        const eVals = series.map(r=>r.energyWh).filter(v=>v!=null);
        if (eVals.length){
          const avgE = eVals.reduce((a,b)=>a+b,0)/eVals.length;
          if (avgE<20){ // muito pequeno para Wh cumulativo → assume kWh e converte para Wh
            series = series.map(r=> ({...r, energyWh: (r.energyWh!=null ? r.energyWh*1000 : null)}));
          }
        }

        aggregatePerDay();
        renderAll();
      }catch(err){
        console.error(err);
        msg("Erro ao analisar o CSV: " + err.message, "error");
      }
    },
    error: (e)=> msg("Falha no parsing: "+ e.message, "error")
  });
};
</script>
</body>
</html>
